{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dungeon Crawler</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Pirata+One&display=swap');\n        \n        body {\n            margin: 0;\n            font-family: 'MedievalSharp', cursive;\n            background: radial-gradient(circle at center, #2e0500, #100000);\n            color: white;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            overflow: hidden;\n            position: relative;\n            cursor:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADDklEQVR4nO2XT0gUYRiHf1qBaChCHYIuHbpEh4IgAqEuHVI7lp6CiAxq7ZCnuqzQoUN/wFBQyV1TbJetSGe2CNRG25l0pjkUbrAzqRWkO5O1a7VQueIbq7syu625C8F8xj7w3p/fO9/3zvsBBQoUKPCvCQTmKwOqWSUpRoOoGC2ibA4+5KfvgVWIqEiSzWZJNgVJNuckxSRr3R+YGnF5NQGsIirm1UzpVD3gpgW3VyeXV28Fi0iKeXo9+WSA82CNwMvwEVE2f60nn6gun34YLPF8fHaPJBvRXOSTAbaDFUbVTztE2Xyfq7zbq8+BFVRlplSSzfE85ImZCeTz0SZJNvvzkXcnyqM1gwUkxbidr7zLq7c4nVRstzsk2WjKS96jx11e7RxYQJLDtZJiLOYh/63bEzoGFhDluQOibMZyvrAe/aPbp+0HC4yOh3eJimnkPm301529+k6wgKpGKkTZnMj92GhPe3v1crCAqtIWUTGH8jg2nU5B2AxWVmNRNnpykXd5tCVmZvzfVuOs8l7th8sTqgPrq3H2zuufu3yhKrC+Gmc98x7tratvcrdtosThEPVj/3qrcfYLq0kdfaFt9snzqCceRByWyI/GtVbjNeR9bve7EtvkExCPK8sBkiEWH5ddkhRDzXyAZ1vIEtMJdkNPUE4cVGuI2eGzwpqdZ2khS0GDqCAOsjXEzNCZkSzy7CxkVsJNKIs2wh/vQdAa4s2jU6tHx+XRPtzxTu4Fa8w0oDRyAcNRByjqwNf43T9DMLWQZXY+4oCQlF+u6XoMxjrSQywMlDSB8c5ToiZPQgjWgII1mI+1p4cgDhftdgY5UZyD/Eodhz9zOpEf9j1KiMdN4rFIHLojDgxlyI9Y5SeqEQiewFbyozIthB8H7QzwPSXysw0vIg4sZOt8Sj7tP8HjMnGwd8skHrdWO5kI0YqxqTo8Szs21RBeHUUZWIQIRcSjzRriyzWMBWuwkK3zGytELQTm5dNCcOiwhkhcbGwkaOVLtFsCxFMjdsNAK1/iBnGIEY/rdvsUKFDgP+I3oaQkm96T7k8AAAAASUVORK5CYII='), auto;\n        }\n\n        .pattern-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-image: url(\"data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30z' fill='none' stroke='%23784421' stroke-width='1' opacity='0.1'/%3E%3C/svg%3E\");\n            pointer-events: none;\n            z-index: 1;\n            opacity: 0.1;\n        }\n\n        #start-screen {\n            text-align: center;\n            position: relative;\n            padding: 60px;\n            z-index: 2;\n            background: rgba(0, 0, 0, 0.5);\n            border-radius: 15px;\n            border: 3px solid #945522;\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 40px #ffd700;\n        }\n\n        h1 {\n            font-family: 'Pirata One', cursive;\n            font-size: 6.5em;\n            margin: 0 0 30px;\n            color: #ffd700;\n            text-shadow: 4px 4px 8px rgba(0,0,0,0.7), 0 0 20px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.2);\n        }\n\n        .manual {\n            background: rgba(46, 5, 0, 0.8);\n            border: 2px solid #784421;\n            padding: 20px;\n            margin-bottom: 30px;\n            border-radius: 10px;\n            max-width: 800px;\n            margin-left: auto;\n            margin-right: auto;\n        }\n\n        .manual h2 {\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            font-size: 1.8em;\n            margin-top: 0;\n            margin-bottom: 20px;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);\n        }\n\n        .manual-content {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 30px;\n            margin-bottom: 20px;\n        }\n\n        .controls {\n            display: grid;\n            grid-template-columns: auto auto;\n            gap: 15px;\n            justify-content: center;\n            align-items: center;\n            text-align: left;\n        }\n\n        .gameplay-tips {\n            text-align: left;\n            border-left: 2px solid #784421;\n            padding-left: 20px;\n        }\n\n        .gameplay-tips h3 {\n            color: #ffd700;\n            margin-top: 0;\n            font-size: 1.2em;\n        }\n\n        .gameplay-tips ul {\n            margin: 0;\n            padding-left: 20px;\n            list-style-type: none;\n        }\n\n        .gameplay-tips li {\n            margin-bottom: 8px;\n            position: relative;\n        }\n\n        .gameplay-tips li:before {\n            content: \"►\";\n            color: #ffd700;\n            position: absolute;\n            left: -20px;\n            font-size: 0.8em;\n        }\n\n        .key {\n            background: linear-gradient(to bottom, #784421, #4a2a15);\n            padding: 8px 15px;\n            border-radius: 5px;\n            color: #ffd700;\n            font-weight: bold;\n            text-align: center;\n            border: 1px solid #945522;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n            min-width: 80px;\n        }\n\n        .action {\n            color: #ffffff;\n            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);\n        }\n\n        #start-button {\n            padding: 20px 50px;\n            font-size: 28px;\n            cursor: pointer;\n            border: 3px solid #784421;\n            background: linear-gradient(to bottom, #2a1810, #1a0f0a);\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            text-transform: uppercase;\n            letter-spacing: 3px;\n            transition: all 0.4s ease;\n            clip-path: polygon(10% 0, 90% 0, 100% 50%, 90% 100%, 10% 100%, 0 50%);\n            position: relative;\n            overflow: hidden;\n            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.1);\n        }\n\n        #start-button:hover {\n            transform: translateY(-3px) scale(1.05);\n            box-shadow: 0 8px 16px rgba(0,0,0,0.5), 0 0 30px rgba(255,215,0,0.2);\n            text-shadow: 0 0 10px rgba(255,215,0,0.5);\n            border-color: #945522;\n        }\n\n        #start-button:active {\n            transform: translateY(2px) scale(0.98);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(255,215,0,0.1);\n        }\n\n        .corner-decoration {\n            position: absolute;\n            width: 60px;\n            height: 60px;\n            background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M10,50 L30,20 L70,20 L90,50 L70,80 L30,80 Z' fill='%23784421' opacity='0.4'/%3E%3C/svg%3E\");\n            background-size: contain;\n            background-repeat: no-repeat;\n        }\n\n        .top-left { top: 20px; left: 20px; transform: rotate(0deg); }\n        .top-right { top: 20px; right: 20px; transform: rotate(90deg); }\n        .bottom-left { bottom: 20px; left: 20px; transform: rotate(270deg); }\n        .bottom-right { bottom: 20px; right: 20px; transform: rotate(180deg); }\n\n        #tooltip {\n            position: absolute;\n            display: none;\n            background: rgba(0, 0, 0, 0.8);\n            padding: 5px 10px;\n            border-radius: 5px;\n            font-size: 0.9em;\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n        }\n\n        @keyframes flicker {\n            0% { opacity: 1; }\n            50% { opacity: 0.8; }\n            100% { opacity: 1; }\n        }\n        \n        #start-screen { animation: flicker 3s infinite; }\n    </style>\n</head>\n<body>\n    <div class=\"pattern-overlay\"></div>\n    <div class=\"corner-decoration top-left\"></div>\n    <div class=\"corner-decoration top-right\"></div>\n    <div class=\"corner-decoration bottom-left\"></div>\n    <div class=\"corner-decoration bottom-right\"></div>\n    <div id=\"tooltip\">Click to enter the dungeon!</div>\n    <div id=\"start-screen\">\n        <h1>DUNGEON CRAWLER</h1>\n        <div class=\"manual\">\n            <h2>How to Play</h2>\n            <div class=\"manual-content\">\n                <div class=\"controls-section\">\n                    <div class=\"controls\">\n                        <div class=\"key\">↑ ↓ ← →</div>\n                        <div class=\"action\">Movement</div>\n                        <div class=\"key\">A</div>\n                        <div class=\"action\">Turn Left</div>\n                        <div class=\"key\">D</div>\n                        <div class=\"action\">Turn Right</div>\n                        <div class=\"key\">SPACE</div>\n                        <div class=\"action\">Attack</div>\n                        <div class=\"key\">ENTER</div>\n                        <div class=\"action\">Next Level</div>\n                    </div>\n                </div>\n                <div class=\"gameplay-tips\">\n                    <h2>Quick Guide</h2>\n                    <ul>\n                        <li>Defeat all goblins to complete each level</li>\n\t\t\t\t\t\t<li>You have to face the goblins to attack and kill them. See the total enemies in the top right \t\t\t\t\t\t\tcorner</li>\n                        <li>Use the mini-map to navigate and track enemies</li>\n\t\t\t\t\t\t<li>The green dots in the map are goblins and you can also see them in the first person point of \t\t\t\t\t\t\tview</li>\n                        <li>Time your attacks - there's a cooldown period</li>\n                        <li>Each level gets progressively harder, the map changes and goblins increase</li>\n                    </ul>\n                </div>\n            </div>\n        </div>\n        <button id=\"start-button\">START GAME</button>\n    </div>\n    <div id=\"game-container\" style=\"display: none;\"></div>\n\n    <script>\n        const startButton = document.getElementById('start-button');\n        const tooltip = document.getElementById('tooltip');\n\n        startButton.addEventListener('mouseover', (e) => {\n            tooltip.style.display = 'block';\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mousemove', (e) => {\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mouseout', () => {\n            tooltip.style.display = 'none';\n        });\n    </script>\n</body>\n</html>",
      "status": "",
      "output": "\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dungeon Crawler</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Pirata+One&display=swap');\n        \n        body {\n            margin: 0;\n            font-family: 'MedievalSharp', cursive;\n            background: radial-gradient(circle at center, #2e0500, #100000);\n            color: white;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            overflow: hidden;\n            position: relative;\n            cursor:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADDklEQVR4nO2XT0gUYRiHf1qBaChCHYIuHbpEh4IgAqEuHVI7lp6CiAxq7ZCnuqzQoUN/wFBQyV1TbJetSGe2CNRG25l0pjkUbrAzqRWkO5O1a7VQueIbq7syu625C8F8xj7w3p/fO9/3zvsBBQoUKPCvCQTmKwOqWSUpRoOoGC2ibA4+5KfvgVWIqEiSzWZJNgVJNuckxSRr3R+YGnF5NQGsIirm1UzpVD3gpgW3VyeXV28Fi0iKeXo9+WSA82CNwMvwEVE2f60nn6gun34YLPF8fHaPJBvRXOSTAbaDFUbVTztE2Xyfq7zbq8+BFVRlplSSzfE85ImZCeTz0SZJNvvzkXcnyqM1gwUkxbidr7zLq7c4nVRstzsk2WjKS96jx11e7RxYQJLDtZJiLOYh/63bEzoGFhDluQOibMZyvrAe/aPbp+0HC4yOh3eJimnkPm301529+k6wgKpGKkTZnMj92GhPe3v1crCAqtIWUTGH8jg2nU5B2AxWVmNRNnpykXd5tCVmZvzfVuOs8l7th8sTqgPrq3H2zuufu3yhKrC+Gmc98x7tratvcrdtosThEPVj/3qrcfYLq0kdfaFt9snzqCceRByWyI/GtVbjNeR9bve7EtvkExCPK8sBkiEWH5ddkhRDzXyAZ1vIEtMJdkNPUE4cVGuI2eGzwpqdZ2khS0GDqCAOsjXEzNCZkSzy7CxkVsJNKIs2wh/vQdAa4s2jU6tHx+XRPtzxTu4Fa8w0oDRyAcNRByjqwNf43T9DMLWQZXY+4oCQlF+u6XoMxjrSQywMlDSB8c5ToiZPQgjWgII1mI+1p4cgDhftdgY5UZyD/Eodhz9zOpEf9j1KiMdN4rFIHLojDgxlyI9Y5SeqEQiewFbyozIthB8H7QzwPSXysw0vIg4sZOt8Sj7tP8HjMnGwd8skHrdWO5kI0YqxqTo8Szs21RBeHUUZWIQIRcSjzRriyzWMBWuwkK3zGytELQTm5dNCcOiwhkhcbGwkaOVLtFsCxFMjdsNAK1/iBnGIEY/rdvsUKFDgP+I3oaQkm96T7k8AAAAASUVORK5CYII='), auto;\n        }\n\n        .pattern-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-image: url(\"data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30z' fill='none' stroke='%23784421' stroke-width='1' opacity='0.1'/%3E%3C/svg%3E\");\n            pointer-events: none;\n            z-index: 1;\n            opacity: 0.1;\n        }\n\n        #start-screen {\n            text-align: center;\n            position: relative;\n            padding: 60px;\n            z-index: 2;\n            background: rgba(0, 0, 0, 0.5);\n            border-radius: 15px;\n            border: 3px solid #945522;\n            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7), 0 0 40px #ffd700;\n        }\n\n        h1 {\n            font-family: 'Pirata One', cursive;\n            font-size: 6.5em;\n            margin: 0 0 30px;\n            color: #ffd700;\n            text-shadow: 4px 4px 8px rgba(0,0,0,0.7), 0 0 20px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.2);\n        }\n\n        .manual {\n            background: rgba(46, 5, 0, 0.8);\n            border: 2px solid #784421;\n            padding: 20px;\n            margin-bottom: 30px;\n            border-radius: 10px;\n            max-width: 800px;\n            margin-left: auto;\n            margin-right: auto;\n        }\n\n        .manual h2 {\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            font-size: 1.8em;\n            margin-top: 0;\n            margin-bottom: 20px;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);\n        }\n\n        .manual-content {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 30px;\n            margin-bottom: 20px;\n        }\n\n        .controls {\n            display: grid;\n            grid-template-columns: auto auto;\n            gap: 15px;\n            justify-content: center;\n            align-items: center;\n            text-align: left;\n        }\n\n        .gameplay-tips {\n            text-align: left;\n            border-left: 2px solid #784421;\n            padding-left: 20px;\n        }\n\n        .gameplay-tips h3 {\n            color: #ffd700;\n            margin-top: 0;\n            font-size: 1.2em;\n        }\n\n        .gameplay-tips ul {\n            margin: 0;\n            padding-left: 20px;\n            list-style-type: none;\n        }\n\n        .gameplay-tips li {\n            margin-bottom: 8px;\n            position: relative;\n        }\n\n        .gameplay-tips li:before {\n            content: \"►\";\n            color: #ffd700;\n            position: absolute;\n            left: -20px;\n            font-size: 0.8em;\n        }\n\n        .key {\n            background: linear-gradient(to bottom, #784421, #4a2a15);\n            padding: 8px 15px;\n            border-radius: 5px;\n            color: #ffd700;\n            font-weight: bold;\n            text-align: center;\n            border: 1px solid #945522;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n            min-width: 80px;\n        }\n\n        .action {\n            color: #ffffff;\n            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);\n        }\n\n        #start-button {\n            padding: 20px 50px;\n            font-size: 28px;\n            cursor: pointer;\n            border: 3px solid #784421;\n            background: linear-gradient(to bottom, #2a1810, #1a0f0a);\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n            text-transform: uppercase;\n            letter-spacing: 3px;\n            transition: all 0.4s ease;\n            clip-path: polygon(10% 0, 90% 0, 100% 50%, 90% 100%, 10% 100%, 0 50%);\n            position: relative;\n            overflow: hidden;\n            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.1);\n        }\n\n        #start-button:hover {\n            transform: translateY(-3px) scale(1.05);\n            box-shadow: 0 8px 16px rgba(0,0,0,0.5), 0 0 30px rgba(255,215,0,0.2);\n            text-shadow: 0 0 10px rgba(255,215,0,0.5);\n            border-color: #945522;\n        }\n\n        #start-button:active {\n            transform: translateY(2px) scale(0.98);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(255,215,0,0.1);\n        }\n\n        .corner-decoration {\n            position: absolute;\n            width: 60px;\n            height: 60px;\n            background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M10,50 L30,20 L70,20 L90,50 L70,80 L30,80 Z' fill='%23784421' opacity='0.4'/%3E%3C/svg%3E\");\n            background-size: contain;\n            background-repeat: no-repeat;\n        }\n\n        .top-left { top: 20px; left: 20px; transform: rotate(0deg); }\n        .top-right { top: 20px; right: 20px; transform: rotate(90deg); }\n        .bottom-left { bottom: 20px; left: 20px; transform: rotate(270deg); }\n        .bottom-right { bottom: 20px; right: 20px; transform: rotate(180deg); }\n\n        #tooltip {\n            position: absolute;\n            display: none;\n            background: rgba(0, 0, 0, 0.8);\n            padding: 5px 10px;\n            border-radius: 5px;\n            font-size: 0.9em;\n            color: #ffd700;\n            font-family: 'MedievalSharp', cursive;\n        }\n\n        @keyframes flicker {\n            0% { opacity: 1; }\n            50% { opacity: 0.8; }\n            100% { opacity: 1; }\n        }\n        \n        #start-screen { animation: flicker 3s infinite; }\n    </style>\n\n\n    <div class=\"pattern-overlay\"></div>\n    <div class=\"corner-decoration top-left\"></div>\n    <div class=\"corner-decoration top-right\"></div>\n    <div class=\"corner-decoration bottom-left\"></div>\n    <div class=\"corner-decoration bottom-right\"></div>\n    <div id=\"tooltip\">Click to enter the dungeon!</div>\n    <div id=\"start-screen\">\n        <h1>DUNGEON CRAWLER</h1>\n        <div class=\"manual\">\n            <h2>How to Play</h2>\n            <div class=\"manual-content\">\n                <div class=\"controls-section\">\n                    <div class=\"controls\">\n                        <div class=\"key\">↑ ↓ ← →</div>\n                        <div class=\"action\">Movement</div>\n                        <div class=\"key\">A</div>\n                        <div class=\"action\">Turn Left</div>\n                        <div class=\"key\">D</div>\n                        <div class=\"action\">Turn Right</div>\n                        <div class=\"key\">SPACE</div>\n                        <div class=\"action\">Attack</div>\n                        <div class=\"key\">ENTER</div>\n                        <div class=\"action\">Next Level</div>\n                    </div>\n                </div>\n                <div class=\"gameplay-tips\">\n                    <h2>Quick Guide</h2>\n                    <ul>\n                        <li>Defeat all goblins to complete each level</li>\n\t\t\t\t\t\t<li>You have to face the goblins to attack and kill them. See the total enemies in the top right \t\t\t\t\t\t\tcorner</li>\n                        <li>Use the mini-map to navigate and track enemies</li>\n\t\t\t\t\t\t<li>The green dots in the map are goblins and you can also see them in the first person point of \t\t\t\t\t\t\tview</li>\n                        <li>Time your attacks - there's a cooldown period</li>\n                        <li>Each level gets progressively harder, the map changes and goblins increase</li>\n                    </ul>\n                </div>\n            </div>\n        </div>\n        <button id=\"start-button\">START GAME</button>\n    </div>\n    <div id=\"game-container\" style=\"display: none;\"></div>\n\n    <script>\n        const startButton = document.getElementById('start-button');\n        const tooltip = document.getElementById('tooltip');\n\n        startButton.addEventListener('mouseover', (e) => {\n            tooltip.style.display = 'block';\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mousemove', (e) => {\n            tooltip.style.left = e.pageX + 'px';\n            tooltip.style.top = e.pageY - 30 + 'px';\n        });\n\n        startButton.addEventListener('mouseout', () => {\n            tooltip.style.display = 'none';\n        });\n    </script>\n\n",
      "type": "html"
    },
    {
      "code": "\nconst bgSound =  new Audio(\"https://github.com/Adam-Warlock09/Space-Invaders/blob/main/assets/sounds/bg.mp3?raw=true\")\n\nbgSound.loop = true  // Enable background music looping\nbgSound.volume = 0.08  // Set background music volume to low level\nbgSound.play()   // Start playing background music\n\n\n\nfunction startGame() {\n  \t// Canvas Setup\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = 1000;  // Set game width to 1000px\n    canvas.height = 700;   // Set game height to 700px\n    document.getElementById('game-container').appendChild(canvas);\n\n    // Game Constants\n  \tconst CROSSHAIR_SIZE = 20;\n\tlet isEnemyTargeted = false;\n\tlet targetedEnemy = null;\n    const BASE_ENEMY_COUNT = 5;  // Starting number of enemies per level\n    const ENEMY_INCREASE_PER_LEVEL = 2;  // Additional enemies added each level\n    let currentLevel = 1;   // Track current game level\n    const TWO_PI = Math.PI * 2;  // Constant for full circle in radians\n    const PI = Math.PI;  // Standard PI constant\n    const width = 1000;  // Game window width\n    const height = 700;  // Game window height\n    const rows = 70;     // Grid rows for game map\n    const cols = 100;    // Grid columns for game map\n    const viewAngle = 3.0 * Math.PI / 4.0;  // Player's field of view in radians\n    const defaultColor = { r: 255, g: 12, b: 100 };  // Default color for entities\n  \t\n  \t// Movement and rotation constants\n    const qR = Math.PI / 30;  // Rotation increment per key press\n  \n    // Game state variables\n    let game, player;    // Main game and player objects\n    let scaleX = 10;     // X-axis scaling factor for map\n    let scaleY = 10;     // Y-axis scaling factor for map\n    let topLeftX = width - 220;   // Map X position (right side)\n    let topLeftY = 20;       // Map Y position (top padding)\n    let maxDiagonal = 1000;    // Maximum ray distance\n    let looping = true;     // Game loop control flag\n    \n    // Combat constants\n    const ENEMY_COUNT = 5;                   // Initial enemy count\n    const PLAYER_MAX_HEALTH = 100;           // Maximum player health\n    const ENEMY_MAX_HEALTH = 50;             // Maximum enemy health\n    const ATTACK_RANGE = 5;                  // Range for attack hits\n    const ATTACK_DAMAGE = 20;                // Damage dealt by player attacks\n    const ENEMY_DAMAGE = 2;                  // Damage dealt by enemy attacks\n    const ENEMY_ATTACK_COOLDOWN = 60;        // Frames between enemy attacks\n    let gameOver = false;                    // Game over state flag\n\n    // Utility functions (keeping existing ones)\n    function random(min, max) { return Math.random() * (max - min) + min; }\n    function floor(n) { return Math.floor(n); }\n    function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)); }\n\n    // Enemy class\n    class Enemy {\n    constructor(x, y) {\n            // Enemy position and stats\n            this.x = x;\n            this.y = y;\n            this.health = ENEMY_MAX_HEALTH;\n            this.color = { r: 76, g: 153, b: 0 };  // Goblin green color\n            \n            // Animation and combat states\n            this.moveCounter = 0;            // Timer for movement\n            this.attackCooldown = 0;         // Timer between attacks\n            this.attackAnimation = 0;        // Current attack animation frame\n            this.deathAnimation = 0;         // Current death animation frame\n            this.isDying = false;            // Death state flag\n            this.size = 1;                   // Size multiplier for animations\n            \n            // Visual features for goblin appearance\n            this.features = {\n                ears: { x: 0.3, y: 0.2, size: 0.3 },\n                eyes: { x: 0.3, y: 0.4, size: 0.15 },\n                nose: { x: 0.5, y: 0.6, size: 0.2 }\n            };\n            this.animationFrame = 0;         // Current animation frame\n        }\n\n    update(player) {\n        if (this.isDying) {\n            this.deathAnimation++;\n            if (this.deathAnimation >= 30) {\n                return true; // Remove enemy\n            }\n            this.size = Math.max(0.2, 1 - (this.deathAnimation / 30));\n            this.color.g += 2; // Fade to yellow\n            return false;\n        }\n\n        // Animate goblin features\n        this.animationFrame = (this.animationFrame + 1) % 60;\n        this.features.ears.y = 0.2 + Math.sin(this.animationFrame * 0.1) * 0.05;\n        \n        // Update movement\n        this.moveCounter++;\n        if (this.moveCounter >= 30) {\n            this.moveCounter = 0;\n            this.moveTowardsPlayer(player);\n        }\n\n        // Update attack\n        if (this.attackCooldown > 0) {\n            this.attackCooldown--;\n            if (this.attackAnimation > 0) {\n                this.attackAnimation--;\n            }\n        } else {\n            // Attack player if in range\n            if (dist(this.x, this.y, player.x, player.y) < ATTACK_RANGE) {\n                player.takeDamage(ENEMY_DAMAGE);\n                this.attackCooldown = ENEMY_ATTACK_COOLDOWN;\n                this.attackAnimation = 10; // Start attack animation\n                \n                // Create attack effect\n                createAttackEffect(this.x, this.y, player.x, player.y);\n            }\n        }\n    }\n\n    moveTowardsPlayer(player) {\n        const dx = player.x - this.x;\n        const dy = player.y - this.y;\n        \n        // Simple pathfinding\n        let newX = this.x;\n        let newY = this.y;\n        \n        if (Math.abs(dx) > Math.abs(dy)) {\n            newX += Math.sign(dx);\n        } else {\n            newY += Math.sign(dy);\n        }\n\n        // Check if new position is valid\n        if (!bumpingIntoWall(newX, newY) && inBounds(newX, 0, cols - 1) && inBounds(newY, 0, rows - 1)) {\n            this.x = newX;\n            this.y = newY;\n        }\n    }\n\n    takeDamage(damage) {\n    this.health -= damage;\n    if (this.health <= 0) {\n        game.effects.push(new VisualEffect('death', this.x, this.y, 30));\n        return true;\n    }\n    game.effects.push(new VisualEffect('hit', this.x, this.y, 15));\n    return false;\n}\n\n    draw(game, topLeftX, topLeftY) {\n        const scale = this.size * game.scaleX;\n        const x = topLeftX + this.x * game.scaleX;\n        const y = topLeftY + this.y * game.scaleY;\n\n        if (this.isDying) {\n            // Draw death animation\n            ctx.fillStyle = `rgba(${this.color.r},${this.color.g},0,${1 - this.deathAnimation/30})`;\n            ctx.beginPath();\n            ctx.arc(x + scale/2, y + scale/2, scale * (1 - this.deathAnimation/30), 0, Math.PI * 2);\n            ctx.fill();\n            return;\n        }\n\n        // Draw goblin body\n        ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;\n        ctx.fillRect(x, y, scale, scale);\n\n        // Draw goblin features\n        // Ears\n        ctx.fillStyle = 'rgb(50,100,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.ears.x * scale, y + this.features.ears.y * scale, \n                this.features.ears.size * scale, 0, Math.PI * 2);\n        ctx.arc(x + (1 - this.features.ears.x) * scale, y + this.features.ears.y * scale, \n                this.features.ears.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Eyes\n        ctx.fillStyle = 'rgb(255,255,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.eyes.x * scale, y + this.features.eyes.y * scale, \n                this.features.eyes.size * scale, 0, Math.PI * 2);\n        ctx.arc(x + (1 - this.features.eyes.x) * scale, y + this.features.eyes.y * scale, \n                this.features.eyes.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Nose\n        ctx.fillStyle = 'rgb(40,80,0)';\n        ctx.beginPath();\n        ctx.arc(x + this.features.nose.x * scale, y + this.features.nose.y * scale, \n                this.features.nose.size * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Attack animation\n        if (this.attackAnimation > 0) {\n            ctx.strokeStyle = 'rgba(255,0,0,0.5)';\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.arc(x + scale/2, y + scale/2, \n                    scale * (1 + this.attackAnimation/5), 0, Math.PI * 2);\n            ctx.stroke();\n        }\n\n        // Health bar\n        const healthBarWidth = scale;\n        const healthBarHeight = 2;\n        const healthPercentage = this.health / ENEMY_MAX_HEALTH;\n        \n        ctx.fillStyle = 'red';\n        ctx.fillRect(x, y - healthBarHeight - 1, healthBarWidth, healthBarHeight);\n        \n        ctx.fillStyle = 'green';\n        ctx.fillRect(x, y - healthBarHeight - 1, healthBarWidth * healthPercentage, healthBarHeight);\n    }\n}\n\n// Visual effects system\nconst effects = [];\n\nfunction createAttackEffect(startX, startY, endX, endY) {\n    effects.push({\n        type: 'attack',\n        startX: startX,\n        startY: startY,\n        endX: endX,\n        endY: endY,\n        duration: 10,\n        current: 0\n    });\n}\n\nfunction createDeathEffect(x, y) {\n    for (let i = 0; i < 8; i++) {\n        const angle = (Math.PI * 2 * i) / 8;\n        effects.push({\n            type: 'death',\n            x: x,\n            y: y,\n            dx: Math.cos(angle) * 0.2,\n            dy: Math.sin(angle) * 0.2,\n            duration: 30,\n            current: 0\n        });\n    }\n}\n\n  class VisualEffect {\n        constructor(type, x, y, duration) {\n            this.type = type;                // Effect type (death, hit, etc.)\n            this.x = x;                      // Effect X position\n            this.y = y;                      // Effect Y position\n            this.duration = duration;         // Effect lifetime in frames\n            this.currentFrame = 0;           // Current animation frame\n            this.scale = 1;                  // Size multiplier\n            this.opacity = 1;                // Transparency value\n        }\n\n    update() {\n        this.currentFrame++;\n        const progress = this.currentFrame / this.duration;\n        \n        if (this.type === 'death') {\n            this.scale = 1 + progress;\n            this.opacity = 1 - progress;\n        } else if (this.type === 'hit') {\n            this.scale = 1 - progress * 0.5;\n            this.opacity = 1 - progress;\n        }\n        \n        return this.currentFrame < this.duration;\n    }\n\n    draw(ctx, cx, cy, w, h) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        \n        if (this.type === 'death') {\n            // Explosion effect\n            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * this.scale);\n            gradient.addColorStop(0, 'rgba(255,255,0,0.8)');\n            gradient.addColorStop(0.6, 'rgba(255,100,0,0.5)');\n            gradient.addColorStop(1, 'rgba(255,0,0,0)');\n            \n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(cx, cy, w * this.scale, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (this.type === 'hit') {\n            // Hit effect\n            ctx.fillStyle = 'rgba(255,0,0,0.5)';\n            ctx.beginPath();\n            ctx.arc(cx, cy, w * this.scale, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        ctx.restore();\n    }\n}\n\n    // Enhanced Player class\n    class Player {\n        constructor(x, y, dir, options) {\n            this.x = x;                      // Player X position\n            this.y = y;                      // Player Y position\n            this.dir = dir;                  // Player facing direction\n            this.color = options?.color || defaultColor;  // Player color\n            this.health = PLAYER_MAX_HEALTH; // Current health\n            this.attackCooldown = 0;         // Timer between attacks\n        }\n\n        modDir() {\n            this.dir = this.dir + 2 * TWO_PI;\n            this.dir = this.dir - (Math.floor(this.dir / TWO_PI) * TWO_PI);\n            if (this.dir < 0) this.dir = this.dir + TWO_PI;\n        }\n        \n        rotate(v) {\n            this.dir = this.dir + v;\n            this.modDir();\n        }\n        \n        rotateRight() {\n            this.rotate(-qR);\n        }\n        \n        rotateLeft() {\n            this.rotate(qR);\n        }\n        \n        move(vx, vy) {\n            this.x += vx;\n            this.y += vy;\n        }\n        \n        moveForward() {\n            if (this.dir <= PI / 8) this.move(1, 0);\n            else if (this.dir <= PI / 8 + PI / 4) this.move(1, 1);\n            else if (this.dir <= PI / 8 + PI / 2) this.move(0, 1);\n            else if (this.dir <= PI / 8 + 3 * PI / 4) this.move(-1, 1);\n            else if (this.dir <= PI / 8 + PI) this.move(-1, 0);\n            else if (this.dir <= PI / 8 + 5 * PI / 4) this.move(-1, -1);\n            else if (this.dir <= PI / 8 + 3 * PI / 2) this.move(0, -1);\n            else if (this.dir <= PI / 8 + 7 * PI / 4) this.move(1, -1);\n            else this.move(1, 0);\n        }\n        \n        moveBackward() {\n            let originalDir = this.dir;\n            this.dir += PI;\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n        \n        moveLeft() {\n            let originalDir = this.dir;\n            this.dir += (-PI / 2);\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n        \n        moveRight() {\n            let originalDir = this.dir;\n            this.dir += (PI / 2);\n            this.modDir();\n            this.moveForward();\n            this.dir = originalDir;\n        }\n\n        // New player methods\n        attack() {\n            if (this.attackCooldown > 0) return;\n            \n            // Attack enemies in range\n            for (let i = enemies.length - 1; i >= 0; i--) {\n                const enemy = enemies[i];\n                const distance = dist(this.x, this.y, enemy.x, enemy.y);\n                \n                if (distance < ATTACK_RANGE) {\n                    // Check if enemy is in player's view direction\n                    const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);\n                    let angleDiff = Math.abs(angleToEnemy - this.dir);\n                    \n                    // Normalize angle difference\n                    if (angleDiff > Math.PI) {\n                        angleDiff = 2 * Math.PI - angleDiff;\n                    }\n                    \n                    // Attack if enemy is within view cone (120 degrees)\n                    if (angleDiff < Math.PI / 3) {\n                        if (enemy.takeDamage(ATTACK_DAMAGE)) {\n                            enemies.splice(i, 1); // Remove dead enemy\n                        }\n                    }\n                }\n\t\t\t   if (targetedEnemy.takeDamage(ATTACK_DAMAGE)) {\n            const index = enemies.indexOf(targetedEnemy);\n            if (index > -1) {\n                enemies.splice(index, 1);\n            }\n        }\n            }\n            \n            this.attackCooldown = 20; // 20 frames cooldown\n        }\n\n        takeDamage(damage) {\n            if (this.damageImmunity > 0) return; // Don't take damage if immune\n            \n            this.health -= damage;\n            this.damageImmunity = 30; // Set immunity frames after taking damage\n            \n            if (this.health <= 0 && !gameOver) {\n                gameOver = true;\n                alert('Game Over! Press OK to restart.');\n                setup();\n            }\n        }\n\n        update() {\n            if (this.attackCooldown > 0) this.attackCooldown--;\n            if (this.damageImmunity > 0) this.damageImmunity--;\n        }\n    }\n\n    // Enhanced Game class\n   class Game {\n        constructor(width, height, rows, cols) {\n            // Game dimensions and grid setup\n            this.width = width;\n            this.height = height;\n            this.cols = cols;\n            this.rows = rows;\n            this.scaleX = this.width / this.cols;\n            this.scaleY = this.height / this.rows;\n            \n            // Game state storage\n            this.design = [];                // Map layout grid\n            this.effects = [];               // Active visual effects\n            this.player = undefined;         // Player reference\n            \n            // Initialize empty map grid\n            for (let i = 0; i < this.rows; i++) {\n                let row = [];\n                for (let j = 0; j < this.cols; j++) {\n                    row.push(0);\n                }\n                this.design.push(row);\n            }\n        }\n\n\n        // Keep existing Game methods...\n        place(y, x, locations) {\n            if (!locations) this.design[y][x] = 1;\n            else for (let v of locations) {\n                this.design[v.y][v.x] = 1;\n            }\n        }\n\n        placeLine(y1, x1, y2, x2) {\n            if (y1 == y2) {\n                for (let j = Math.min(x1, x2); j <= Math.max(x1, x2); j++) {\n                    this.place(y1, j);\n                }\n            } else if (x1 == x2) {\n                for (let i = Math.min(y1, y2); i <= Math.max(y1, y2); i++) {\n                    this.place(i, x1);\n                }\n            }\n        }\n\n        addPlayer(player) {\n            this.player = player;\n\t\t}\n\n        // Enhanced draw method\n        draw(topLeftX, topLeftY) {\n            // Draw mini-map background\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent background\n            ctx.fillRect(topLeftX - 10, topLeftY - 10, this.width + 20, this.height + 20);\n            \n\t\t  // Update and draw effects\n\t\t    this.effects = this.effects.filter(effect => effect.update());\n\t\t\tthis.effects.forEach(effect => {\n\t\t\t\teffect.draw(ctx, \n\t\t\t\t\teffect.x * this.scaleX + this.scaleX/2, \n\t\t\t\t\teffect.y * this.scaleY + this.scaleY/2,\n\t\t\t\t\tthis.scaleX,\n\t\t\t\t\tthis.scaleY\n\t\t\t\t);\n\t\t\t});\n            // Draw game border\n            ctx.strokeStyle = 'white';\n            ctx.fillStyle = 'rgb(10,10,10)';\n            ctx.fillRect(topLeftX, topLeftY, this.width, this.height);\n            ctx.strokeRect(topLeftX, topLeftY, this.width, this.height);\n            \n            // Draw walls\n            for (let i = 0; i < this.rows; i++) {\n                for (let j = 0; j < this.cols; j++) {\n                    if (this.design[i][j] == 1) {\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(\n                            topLeftX + j * this.scaleX,\n                            topLeftY + i * this.scaleY,\n                            this.scaleX,\n                            this.scaleY\n                        );\n                    }\n                }\n            }\n\n            // Draw enemies\n            for (const enemy of enemies) {\n                enemy.draw(this, topLeftX, topLeftY);\n            }\n            \n            // Draw player\n            if (this.player) {\n                ctx.fillStyle = `rgb(${this.player.color.r},${this.player.color.g},${this.player.color.b})`;\n                ctx.fillRect(\n                    topLeftX + this.player.x * this.scaleX,\n                    topLeftY + this.player.y * this.scaleY,\n                    this.scaleX,\n                    this.scaleY\n                );\n\n                // Draw view rays\n                ctx.strokeStyle = 'rgba(200,200,200,0.15)';\n                for (let angle = this.player.dir - viewAngle / 2; angle <= this.player.dir + viewAngle / 2; angle += PI / \t\t\t\t\t200) {\n                    let r = 50;\n                    ctx.beginPath();\n                    ctx.moveTo(\n                        topLeftX + this.player.x * this.scaleX + this.scaleX / 2,\n                        topLeftY + this.player.y * this.scaleY + this.scaleY / 2\n                    );\n                    ctx.lineTo(\n                        topLeftX + this.player.x * this.scaleX + this.scaleX / 2 + r * Math.cos(angle),\n                        topLeftY + this.player.y * this.scaleY + this.scaleY / 2 + r * Math.sin(angle)\n                    );\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n\n    // helper functions\n    function spawnEnemy() {\n        let px, py;\n        let safeTries = 1000;\n        while (safeTries--) {\n            px = floor(random(0, cols - 1));\n            py = floor(random(0, rows - 1));\n            if (!bumpingIntoWall(px, py) && dist(px, py, player.x, player.y) > 10) {\n                return new Enemy(px, py);\n            }\n        }\n        return null;\n    }\n\n    // helper functions...\n    function bumpingIntoWall(x, y) {\n        return game.design[y][x] !== 0;\n    }\n\n    function inBounds(v, low, high) {\n        return v <= high && v >= low;\n    }\n\n    // setup function\n\t function setup() {\n        // Create new game instance with scaled dimensions\n        game = new Game(width * 0.2, height * 0.2, rows, cols);\n        maxDiagonal = dist(0, 0, width * 0.2, height * 0.2);\n\n        // Generate level-specific maze layout\n        const mazeLines = generateMazeLines(currentLevel);\n        for (let l of mazeLines) {\n            game.placeLine(l[0], l[1], l[2], l[3]);\n        }\n\n        // Spawn player in safe location\n        let px, py;\n        let safeTries = 1000;\n        while (safeTries--) {\n            px = floor(random(0, cols - 1));\n            py = floor(random(0, rows - 1));\n            if (!bumpingIntoWall(px, py)) break;\n        }\n        player = new Player(px, py, random(0, TWO_PI));\n        game.addPlayer(player);\n\n        // Spawn level-appropriate number of enemies\n        const levelEnemyCount = BASE_ENEMY_COUNT + (currentLevel - 1) * ENEMY_INCREASE_PER_LEVEL;\n        enemies = [];\n        for (let i = 0; i < levelEnemyCount; i++) {\n            const enemy = spawnEnemy();\n            if (enemy) enemies.push(enemy);\n        }\n\n        gameOver = false;\n    }\n\n\n    //draw function\n \tfunction draw() {\n\t  ctx.fillStyle = 'rgb(22,22,22)';\n\t  ctx.fillRect(0, 0, width, height);\n\n\t  // Update game state\n\t  player.update();\n\t  for (const enemy of enemies) {\n\t\t  enemy.update(player);\n\t  }\n\n\t  let dAngle = PI / 200;\n\t  let noOfDivisions = floor(viewAngle / dAngle);\n\t  let dWidth = width / noOfDivisions;\n\t  let divCount = 0;\n\n\t  // Raycasting for walls and enemies\n\t  for (let angle = player.dir - viewAngle / 2; angle <= player.dir + viewAngle / 2; angle += dAngle) {\n\t\t  let d = maxDiagonal;\n\t\t  let hitEnemy = false;\n\t\t  let enemyDist = maxDiagonal;\n\t\t  let currentEnemy = null;\n\n\t\t  // Check for walls\n\t\t  for (let r = 0.1; r < maxDiagonal + 0.1; r += 0.1) {\n\t\t\t  let xx = player.x + (r * Math.cos(angle));\n\t\t\t  let yy = player.y + (r * Math.sin(angle));\n\n\t\t\t  let gridX = floor(xx);\n\t\t\t  let gridY = floor(yy);\n\n\n\t\t\t  if (!(inBounds(gridX, 0, cols - 1) && inBounds(gridY, 0, rows - 1))) {\n\t\t\t\t  break;\n\t\t\t  }\n\n\t\t\t// if the ray hits a wall (grid value 1)\n\t\t\t  else if (inBounds(gridX, 0, cols - 1) && inBounds(gridY, 0, rows - 1) && game.design[gridY][gridX] === 1) {\n\t\t\t\t  d = dist(player.x, player.y, xx, yy); //distance to the wall\n\t\t\t\t  break; // stop checking further along this ray\n\t\t\t  }\n\n\t\t\t  // Check for enemies with improved precision\n\t\t\t  for (const enemy of enemies) {\n\t\t\t\t  const enemyBoundingRadius = 0.5; // Half the enemy's width\n\t\t\t\t  const distToEnemy = dist(xx, yy, enemy.x + 0.5, enemy.y + 0.5);\n\n\t\t\t\t  if (distToEnemy < enemyBoundingRadius) {\n\t\t\t\t\t  let enemyD = dist(player.x, player.y, xx, yy);\n\t\t\t\t\t  if (enemyD < d && (!hitEnemy || enemyD < enemyDist)) {\n\t\t\t\t\t\t  hitEnemy = true;\n\t\t\t\t\t\t  enemyDist = enemyD;\n\t\t\t\t\t\t  currentEnemy = enemy;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\n        // Draw wall slice\n\t    //calculate opacity based on distance\n        let op = floor(255 / (Math.pow(d, 3 / 2)));\n\t  \n\t    // calculate position and size of wall slices\n        ctx.fillStyle = `rgba(255,255,255,${op/255})`;\n\t  \n\t  \n        let cx = divCount * dWidth + dWidth / 2;   //x position of the slice\n        let cy = height / 2;     //centre coordinate(middle of the screen)\n        let w = dWidth;    //width of the slice \n        let h = height * (2 / (d * Math.pow(Math.cos(angle - player.dir), 1)));  // height based on distance\n\t  \n\t  // draw the slice\n        ctx.fillRect(cx - w/2, cy - h/2, w, h);\n\n        // Draw enemy slice if visible with corrected perspective\n        if (hitEnemy && currentEnemy) {\n            const distanceFactor = Math.pow(Math.cos(angle - player.dir), 1);\n            op = floor(255 / (Math.pow(enemyDist, 3 / 2)));\n            h = height * (2 / (enemyDist * distanceFactor));\n            \n            // Draw basic goblin shape\n            ctx.fillStyle = `rgba(76,153,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2, w, h);\n            \n            // Draw goblin features only if close enough\n            if (enemyDist < 20) {\n                const featureOpacity = op/255;\n                const scale = h/100;\n                \n                // Eyes\n                ctx.fillStyle = `rgba(255,255,0,${featureOpacity})`;\n                const eyeSize = scale * 5;\n                const eyeOffset = w * 0.2;\n                ctx.beginPath();\n                ctx.arc(cx - eyeOffset, cy - h * 0.1, eyeSize, 0, TWO_PI);\n                ctx.arc(cx + eyeOffset, cy - h * 0.1, eyeSize, 0, TWO_PI);\n                ctx.fill();\n                \n                // Nose\n                ctx.fillStyle = `rgba(40,80,0,${featureOpacity})`;\n                ctx.beginPath();\n                ctx.arc(cx, cy, eyeSize * 0.8, 0, TWO_PI);\n                ctx.fill();\n            }\n            \n            // Health bar with corrected positioning\n            const healthBarWidth = w;\n            const healthBarHeight = Math.max(2, h * 0.03);\n            const healthPercentage = currentEnemy.health / ENEMY_MAX_HEALTH;\n            \n            ctx.fillStyle = `rgba(255,0,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2 - healthBarHeight * 2, healthBarWidth, healthBarHeight);\n            \n            ctx.fillStyle = `rgba(0,255,0,${op/255})`;\n            ctx.fillRect(cx - w/2, cy - h/2 - healthBarHeight * 2, healthBarWidth * healthPercentage, healthBarHeight);\n        }\n\n        // Continue with floor and ceiling rendering...\n        let floorGradient = ctx.createLinearGradient(0, height - (height - h) / 2, 0, height);\n        floorGradient.addColorStop(0, 'rgba(255,0,0,0.2)');\n        floorGradient.addColorStop(1, 'rgba(0,0,0,0.2)');\n        ctx.fillStyle = floorGradient;\n        ctx.fillRect(divCount * dWidth, height - (height - h) / 2, dWidth, (height - h) / 2);\n\t\t\n\t  \t// ceiling gradient\n        let ceilingGradient = ctx.createLinearGradient(0, 0, 0, (height - h) / 2);\n        ceilingGradient.addColorStop(0, 'rgba(20,20,20,0.2)');\n        ceilingGradient.addColorStop(1, 'rgba(255,0,0,0.2)');\n        ctx.fillStyle = ceilingGradient;\n        ctx.fillRect(divCount * dWidth, 0, dWidth, (height - h) / 2);\n\n        divCount++;\n    }\n\t  effects.forEach((effect, index) => {\n        if (effect.current >= effect.duration) {\n            effects.splice(index, 1);\n            return;\n        }\n\n        if (effect.type === 'attack') {\n            const progress = effect.current / effect.duration;\n            const x = effect.startX + (effect.endX - effect.startX) * progress;\n            const y = effect.startY + (effect.endY - effect.startY) * progress;\n            \n            ctx.fillStyle = `rgba(255,0,0,${1-progress})`;\n            ctx.beginPath();\n            ctx.arc(topLeftX + x * scaleX, topLeftY + y * scaleY, \n                    5 * (1-progress), 0, Math.PI * 2);\n            ctx.fill();\n        } else if (effect.type === 'death') {\n            const progress = effect.current / effect.duration;\n            effect.x += effect.dx;\n            effect.y += effect.dy;\n            \n            ctx.fillStyle = `rgba(255,255,0,${1-progress})`;\n            ctx.beginPath();\n            ctx.arc(topLeftX + effect.x * scaleX, topLeftY + effect.y * scaleY, \n                    3 * (1-progress), 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        effect.current++;\n    });\n\t   const crosshairX = width / 2;\n    const crosshairY = height / 2;\n    \n    // Calculate if an enemy is being targeted\n    isEnemyTargeted = false;\n    targetedEnemy = null;\n    \n    // Cast a single ray from player in looking direction to check for enemies\n    const centerAngle = player.dir;\n    const targetRange = 20; // Maximum targeting distance\n    \n    for (let r = 0.1; r < targetRange; r += 0.1) {\n        let xx = player.x + (r * Math.cos(centerAngle));\n        let yy = player.y + (r * Math.sin(centerAngle));\n        \n        // Check for walls first\n        let gridX = floor(xx);\n        let gridY = floor(yy);\n        \n        if (!inBounds(gridX, 0, cols - 1) || !inBounds(gridY, 0, rows - 1) || \n            game.design[gridY][gridX] === 1) {\n            break; // Stop if we hit a wall\n        }\n        \n        // Check for enemies\n        for (const enemy of enemies) {\n            const enemyBoundingRadius = 0.5;\n            const distToEnemy = dist(xx, yy, enemy.x + 0.5, enemy.y + 0.5);\n            \n            if (distToEnemy < enemyBoundingRadius) {\n                isEnemyTargeted = true;\n                targetedEnemy = enemy;\n                break;\n            }\n        }\n        \n        if (isEnemyTargeted) break;\n    }\n    \n    // Draw crosshair\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = isEnemyTargeted ? 'red' : 'white';\n    \n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(crosshairX, crosshairY, CROSSHAIR_SIZE, 0, Math.PI * 2);\n    ctx.stroke();\n    \n    // Draw cross\n    ctx.beginPath();\n    ctx.moveTo(crosshairX - CROSSHAIR_SIZE, crosshairY);\n    ctx.lineTo(crosshairX + CROSSHAIR_SIZE, crosshairY);\n    ctx.moveTo(crosshairX, crosshairY - CROSSHAIR_SIZE);\n    ctx.lineTo(crosshairX, crosshairY + CROSSHAIR_SIZE);\n    ctx.stroke();\n    \n    // Draw dot in center\n    if (isEnemyTargeted) {\n        ctx.fillStyle = 'red';\n        ctx.beginPath();\n        ctx.arc(crosshairX, crosshairY, 3, 0, Math.PI * 2);\n        ctx.fill();\n    }\n\n\n        // Draw 2D map view\n        game.draw(topLeftX, topLeftY);\n\n        // Draw UI elements with clear positioning\n        // Draw UI background\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(10, 10, 250, 100);\n        \n        // Draw health bar\n        const healthBarWidth = 200;\n        const healthBarHeight = 20;\n        const healthPercentage = player.health / PLAYER_MAX_HEALTH;\n        \n        ctx.fillStyle = 'white';\n        ctx.font = '16px Arial';\n        ctx.fillText(`Health: ${Math.ceil(player.health)}/${PLAYER_MAX_HEALTH}`, 20, 35);\n        \n        ctx.fillStyle = 'red';\n        ctx.fillRect(20, 45, healthBarWidth, healthBarHeight);\n        \n        ctx.fillStyle = 'green';\n        ctx.fillRect(20, 45, healthBarWidth * healthPercentage, healthBarHeight);\n\n        // Draw enemy count\n        ctx.fillStyle = 'white';\n        ctx.fillText(`Enemies Remaining: ${enemies.length}`, 20, 85);\n        \n        // Draw attack status\n        if (player.attackCooldown > 0) {\n            ctx.fillText(`Attack Cooldown: ${Math.ceil(player.attackCooldown/20 * 100)}%`, 20, 105);\n        } else {\n            ctx.fillText('Ready to Attack!', 20, 105);\n        }\n\n        // Draw victory message in center if applicable\n          if (enemies.length === 0) {\n        ctx.fillStyle = 'green';\n        ctx.font = '32px Arial';\n        const victoryText = `Level ${currentLevel} Complete!`;\n        const continueText = 'Press ENTER to continue';\n        const textMetrics = ctx.measureText(victoryText);\n        const continueMetrics = ctx.measureText(continueText);\n        \n        ctx.fillText(victoryText, (width - textMetrics.width) / 2, height/2);\n        ctx.fillText(continueText, (width - continueMetrics.width) / 2, height/2 + 50);\n        \n        // Add level information to UI\n        ctx.font = '16px Arial';\n        ctx.fillStyle = 'white';\n        ctx.fillText(`Current Level: ${currentLevel}`, 20, 125);\n     }\n    }\n  document.addEventListener('keydown', (event) => {\n    if (event.keyCode === 13 && enemies.length === 0) { // Enter key\n        currentLevel++;\n        setup(); // Reset game with new level\n    }\n});\n\n    // Enhanced input handling\n    document.addEventListener('keydown', (event) => {\n        if (!looping) {\n            requestAnimationFrame(gameLoop);\n            looping = true;\n        }\n        \n        if (gameOver) return;\n\n        switch(event.keyCode) {\n            case 65: // A\n                player.rotateRight();\n                break;\n            case 68: // D\n                player.rotateLeft();\n                break;\n            case 38: // UP\n                advanceMove(player.moveForward.bind(player));\n                break;\n            case 40: // DOWN\n                advanceMove(player.moveBackward.bind(player));\n                break;\n            case 39: // RIGHT\n                advanceMove(player.moveRight.bind(player));\n                break;\n            case 37: // LEFT\n                advanceMove(player.moveLeft.bind(player));\n                break;\n            case 32: // SPACE\n                player.attack();\n                break;\n        }\n    });\n\n    document.addEventListener('keyup', () => {\n        setTimeout(() => {\n            looping = false;\n        }, 2000);\n    });\n\n    // Keep existing helper functions\n    function advanceMove(move) {\n        let iX = player.x;\n        let iY = player.y;\n        move.call(player);\n        if (!inBounds(player.x, 0, cols - 1) || !inBounds(player.y, 0, rows - 1) || bumpingIntoWall(player.x, player.y)) {\n            player.x = iX;\n            player.y = iY;\n        }\n    }\n\n    function generateMazeLines(level) {\n    // Base lines from original maze\n    const baseLines = [\n        [10, 20, 10, 60],\n        [10, 70, 10, 90],\n        [10, 20, 55, 20],\n        [60, 20, 60, 40],\n        [60, 50, 60, 60],\n        [60, 60, 50, 60],\n        [40, 60, 30, 60],\n        [60, 60, 60, 70],\n        [60, 70, 60, 90],\n        [60, 90, 10, 90],\n        [40, 20, 40, 30],\n        [50, 35, 50, 40],\n        [45, 35, 50, 35],\n        [25, 30, 25, 40],\n        [25, 35, 45, 35]\n    ];\n\n    // Generate additional lines based on level\n    const additionalLines = [];\n    const additionalWallCount = level * 3; // 3 new walls per level\n\n    for (let i = 0; i < additionalWallCount; i++) {\n        // Generate random wall placement\n        const isVertical = Math.random() > 0.5;\n        let x1, y1, x2, y2;\n\n        if (isVertical) {\n            x1 = x2 = Math.floor(Math.random() * 65) + 5; // Keep within bounds\n            y1 = Math.floor(Math.random() * 40) + 5;\n            y2 = y1 + Math.floor(Math.random() * 20) + 10;\n        } else {\n            y1 = y2 = Math.floor(Math.random() * 65) + 5;\n            x1 = Math.floor(Math.random() * 40) + 5;\n            x2 = x1 + Math.floor(Math.random() * 20) + 10;\n        }\n\n        additionalLines.push([y1, x1, y2, x2]);\n    }\n\n    // Combine base lines with additional lines\n    return [...baseLines, ...additionalLines];\n}\n\n\n    // Game loop\n    function gameLoop() {\n        draw();\n        if (looping) {\n            requestAnimationFrame(gameLoop);\n        }\n    }\n\n    // Start the game\n    setup();\n    gameLoop();\n}\n\n// Start button click event\ndocument.getElementById('start-button').addEventListener('click', () => {\n    document.getElementById('start-screen').style.display = 'none';\n    document.getElementById('game-container').style.display = 'block';\n    startGame();\n});",
      "status": "[2]<br><span style=\"font-size:8px\">2ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}